"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const opentracing_1 = require("opentracing");
const spanSetup_1 = require("../../../../../../service/tracing/spanSetup");
const spanSetup_2 = require("./spanSetup");
const preRequestInterceptor = (http) => (config) => {
    if (!config.tracing) {
        return config;
    }
    const { rootSpan, tracer } = config.tracing;
    const span = tracer.startSpan('http-request', { childOf: rootSpan });
    spanSetup_2.injectRequestInfoOnSpan(span, http, config);
    config.tracing.requestSpan = span;
    tracer.inject(span, opentracing_1.FORMAT_HTTP_HEADERS, config.headers);
    return config;
};
const onResponseSuccess = (response) => {
    if (!response.config.tracing) {
        return response;
    }
    const requestSpan = response.config.tracing.requestSpan;
    spanSetup_2.injectResponseInfoOnSpan(requestSpan, response);
    requestSpan.finish();
    return response;
};
const onResponseError = (err) => {
    var _a, _b;
    if (!((_b = (_a = err === null || err === void 0 ? void 0 : err.config) === null || _a === void 0 ? void 0 : _a.tracing) === null || _b === void 0 ? void 0 : _b.requestSpan)) {
        return Promise.reject(err);
    }
    const { requestSpan } = err.config.tracing;
    spanSetup_2.injectResponseInfoOnSpan(requestSpan, err.response);
    spanSetup_1.injectErrorOnSpan(requestSpan, err);
    requestSpan.finish();
    return Promise.reject(err);
};
exports.addTracingPreRequestInterceptor = (http) => {
    const requestTracingInterceptor = http.interceptors.request.use(preRequestInterceptor(http), undefined);
    return { requestTracingInterceptor };
};
exports.addTracingResponseInterceptor = (http) => {
    const responseTracingInterceptor = http.interceptors.response.use(onResponseSuccess, onResponseError);
    return { responseTracingInterceptor };
};
